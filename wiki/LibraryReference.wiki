#summary A brief introduction to how to use Passpack Hosti-Proof Hosting JS Library

= Installation =

Simply, put into your HTML code the following line:

{{{<script type="text/javascript" src="passpack.js"></script>}}}


= Reference =

== Passpack.encode(_algorithm_,_plaintext_[,_key_,_optionalPars_]) ==

To encode the string {{{str}}} with the key {{{mykey}}} using AES 256-bit use:

{{{Passpack.encode("AES",str,mykey)}}}

By default the result of the encryption is Base64-encoded. To change default settings you can use _optionalPars_. They must be as the following:
{{{
  {
    nbits:  128,
    escape: true
  }
}}}

For example, to encode the string {{{str}}} using AES 192-bit, without Base64 encoding you have to run:

{{{
  Passpack.encode("AES",str,mykey,{
    nbits:    128,
    noBase64: true
  });
}}}

*Supported algorythm:*

 * _UTF8_
 * _Base64+_ (this replace all '+' with '!' to avoid problems with post XMLHTTPRequest)
 * _AES_ (128, 192 or 256-bit)
 * _xxTEA_
 * _RC4_ (this is modified to improve security)

*Optional parameters:*

 * _nbits_ : number of bits, if applicably
 * _noBase64_ : disable Base64 encoding of encrypted string
 * _escape_ : escape the encrypted string (after Base64 encoding)
 * _rounds_ : number of rounds in RC4

Passpack.UTF8 and Passpack.Base64 are based on Utf8 and Base64 scripts by [http://www.webtoolkit.info WebToolkit].
Passpack.AES and Passpack.xxTEA are based on Chris Veness's [http://www.movable-type.co.uk/scripts/aes.html AES] and [http://www.movable-type.co.uk/scripts/tea-block.html BlockTEA] implementations.


== Passpack.decode(_algorithm_,_plaintext_[,_key_,_optionalPars_]) ==

It works similarly to _encode_. Optional pars are the same except:

 * _unescape_ - Unescape encryptedText before decrypt it.

== Passpack.JSON.parse(_jsonString_) ==

The Passpack.JSON static object is a variation of the Douglas Crockford JSON object defined in json2.js library. The _parse_ method adds to original method the automatical conversion of date strings in ISO format to Date objects. To parse a JSON string:

{{{Passpack.JSON.parse(jsonStr);}}}

If you have thoughts to develope a Passpack-compatible application you need this JSON variant.

== Passpack.JSON.stringify(_object_) ==

It is the Crockford JSON method to convert and Object in a JSON string.

== Passpack.getBits(password) ==

Returns the estimated value in bits of a password.

== Passpack.passGenerator(_pars_,_numberOfChars_) ==

It generates a random password. Pars specifies the intervals of chars to be used.

 * lcase: lower case letters
 * ucase: upper case letters
 * nume: numbers
 * symb: symbols
 * space: high ascii chars

For example, to generate a random pass of 16 characters using letters and high ascii chars:

{{{
  Passpack.passGenerator({
    ucase: 1,
    lcase: 1,
    space: 1
  }, 16);
}}}

== Passpack.simplePassGenerator(_numberOfChars_) ==

Generates a password using letters and numbers.

== Passpack.genRandomKey([_size_,_salt_]) ==

Generates a hashed key of _size_ chars, using an optional _salt_. By default generates a 256-bit key (64 chars). If you need a 512-bits key you may concatenate two 256-bit keys.

== Passpack.hashx(_str_,[_nohex_,_full_]) ==

Make a modified hash using SHA256.
_nohex_ produces a standard string instead of an exadecimal string
_full_ produces a 64 chars strings, instead of a default 32 chars modified string

To generate a standard SHA256 hash of the string {{{myStr}}} you can call {{{Passpack.hashx(myStr,false,true);}}}

To generate a non-standard 128-bit hash you can call
{{{Passpack.hashx(myStr);}}}


= Enjoy Passpack Host-Proof Hosting ==